/*
 * File: app/controller/CommonController.js
 *
 * This file was generated by Sencha Architect version 2.2.2.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.2.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.2.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('TouchTreeGrid.controller.CommonController', {
    extend: 'Ext.app.Controller',

    config: {
        refs: {
            main: {
                selector: 'main',
                xtype: 'main'
            },
            griddetailpanel: {
                autoCreate: true,
                selector: 'griddetailpanel',
                xtype: 'griddetailpanel'
            },
            gridHelpPanel: {
                autoCreate: true,
                selector: 'gridHelpPanel',
                xtype: 'gridHelpPanel'
            }
        },

        control: {
            "tabpanel#maintabpanel": {
                activeitemchange: 'onMainTabpanelActiveItemChange'
            },
            "viewport": {
                orientationchange: 'onOrientationChange'
            },
            "titlebar": {
                gridhelp: 'onTitlebarGridhelp'
            },
            "button#griddetailbackbtn": {
                tap: 'onGridDetailBackButtonTap'
            },
            "button#helpPanelCloseBtn": {
                tap: 'onHelpPanelCloseButtonTap'
            }
        }
    },

    onMainTabpanelActiveItemChange: function(container, value, oldValue, eOpts) {
        var newcont = value.getItemId();
        var grid, gridcont, numNodes, mydata, numRecords;

        gridcont = value.down('touchtreegrid');
        grid = gridcont.down('#'+gridcont.getListItemId());

        if (newcont === 'censusmainecontainer') {

            // Check store for data and load if empty (only)
            numNodes = grid.getStore().getData().length;
            if (numNodes === 0) {censusController.loadCensusMaine2000Store();}  
        }

        if (newcont === 'projecttab'){
            // Check store for data and load if empty (only)
            numNodes = grid.getStore().getData().length;
            if (numNodes === 0) {projectController.loadExample2Store(gridcont);}  
        }

        if (newcont === 'listscontainer'){
            numRecords = grid.getStore().getData().length;
            if (numRecords === 0) {
                Ext.Viewport.setMasked({
                    xtype: 'loadmask',
                    message: 'Loading Basic...'
                });
                grid.getStore().load();
                gridcont.doRefreshList();
                Ext.Viewport.setMasked(false);
            }  
        }




    },

    onOrientationChange: function(viewport, orientation, width, height) {
        //Ext.Msg.alert('', 'Orientation change: ' + orientation, Ext.emptyFn); 


        // Call funciton to hide/show titlebar and bottom tabbar when in landscape mode, but only if
        // active window contains TouchGridPanel with active expand/collapse toolbar
        this.hideShowPanels();

        // Demo reconfiguring columns array for Census example based on device and orientation
        censusController.loadColumnsCensusMaine();
    },

    onTitlebarGridhelp: function(main) {
        // Trapping tap event on entire titlebar instead of just help icon
        var me=this;

        var image = main.down('#gridhelp');


        var currItem = Ext.Viewport.down('#maintabpanel').getActiveItem();

        var grid;
        if (currItem.getItemId() === 'projecttab') {
            // Project example contained within sub tab panel so need to get active item of that 
            grid = currItem.down('#projecttabpanel').getActiveItem().down('touchtreegrid');
        } 
        else if (currItem.getItemId() === 'listscontainer') {
            // Lists example contained within sub tab panel so need to get active item of that 
            grid = currItem.down('#liststabpanel').getActiveItem().down('touchtreegrid');
        }
        else if (currItem.getItemId() === 'taskslisttab') {
            // Lists example contained within sub tab panel so need to get active item of that 
            grid = currItem.down('#tasksTabPanel').getActiveItem().down('touchtreegrid');
        } else
        {    
            grid = currItem.down('touchtreegrid');
        }   


        if (!grid) {return;}

        gridId = grid.getHelpHtml();

        Ext.Ajax.request({
            url: gridId,
            method: 'GET',
            callback: function(options, success, response) {

                var help = me.getGridHelpPanel();
                help.setHtml( response.responseText );
                help.showBy(image);
            }
        });
    },

    onGridDetailBackButtonTap: function(button, e, eOpts) {
        // Reusing the Back button for all Project Task examples by storing references when creating detail panel (list disclose)
        var swapcont = button.up('#griddetailpanel').swapcont;  
        if (swapcont)
        {
            gridItemId = button.up('#griddetailpanel').gridItemId;
            var newcont = swapcont.down('#'+gridItemId); 

            newcont.setShowAnimation({type :"slide", direction : "right"});
            swapcont.setActiveItem(newcont);  
        }    
    },

    onHelpPanelCloseButtonTap: function(button, e, eOpts) {
        button.up('gridHelpPanel').hide();
    },

    loadTree: function(collapseLevel, ArrRef, fldListArr, gridcont, rootVal) {
        var me = this;

        var gridlistname = gridcont.getListItemId();
        var gridlist = gridcont.down('#'+gridlistname);

        // Store ArrRef to Grid component for faster collapse/expand
        if (!ArrRef) {ArrRef = gridlist.ArrRef;}  // Array stored with List object and retrieved on subsequent calls
        else {gridlist.ArrRef = ArrRef;}

        var treejson = this.getTree(ArrRef, rootVal, collapseLevel, fldListArr, false);

        // Update current level for next time
        gridcont.collapseLevel = collapseLevel;

        var gridstore = gridlist.getStore();

        gridstore.suspendEvents();

        gridstore.removeAll(true);
        var gridloaded = gridstore.setData(treejson);  // setRoot() not working => http://www.sencha.com/forum/showthread.php?242257
        gridstore.resumeEvents(true);  // discard queued events

        // workaround to get Touch 2.2 pullrefresh plugin to auto-snapBack       
        var scroller = gridlist.getScrollable().getScroller();
        scroller.minPosition.y = 1;
        var refreshed = gridcont.doRefreshList();  

    },

    getTree: function(list, rootId, expLevel, fldListArr, hasTopRoot) {
        // Required Fields:  'ID', 'PARENT_ID'   
        // list       - data array to convert to treestore format
        // rootId     - value of ultimate PARENT_ID (can be null)
        // expLevel   - level to expand treestore to while generating
        // fldListArr - defines columns to include in treestore from ArrRef.  
        //              2nd parameter defined levels including and higher where that data element will be blanked out when generating the treestore
        //              (particularly used for totalled numerics that don't apply to root levels, but the generating SQL can't update as NULL due to SQL UNION constraints 
        // hasTopRoot - true if a single root row exists
        expLevel = (Ext.isEmpty(expLevel) ? 99 : expLevel);  // Level for initial expansion ...Defaults to fully expanded if not provided

        var tree, root = {}, result = []; // fetch list from database
        root.ID = rootId;
        tree = {text : "."};
        result.push(this.createTreeStructure(tree, root, list, 1, expLevel, fldListArr, hasTopRoot));
        return result[0][0];
    },

    createTreeStructure: function(tree, root, list, level, expLevel, fldListArr, hasTopRoot) {
        var i=0, result = [], child, childList = [], children = [], temptree = {}, thisExp;

        if (level === 1 && hasTopRoot) {children = [list[0]];}  // Initial root
        else {children = this.getChildren(root, list, false);} //Fetch children

        var ln = children.length;

        for(i=0; i<ln;i++)
        {
            child = children[i];
            // Blank out categorized data above specified level as pre-specified in fldListArr
            for (var j=0; j< fldListArr.length; j++) {
                if (fldListArr[j][1] > 0 && fldListArr[j][1]>=level) {child[fldListArr[j][0]] = '';}
            }
            if(this.getChildren(child, list, true).length===0) 
            {
                temptree = {LEVEL : level, ID : child.ID, PARENT_ID : child.PARENT_ID, leaf : true};
                this.assignMembers(fldListArr, temptree, child);

                childList.push(temptree);
                tree["children"] = childList; // Add child as child of the passed parent
            }
            else
            {
                thisExp = (level < expLevel ? true : false);
                temptree = {LEVEL : level, ID : child.ID, PARENT_ID : child.PARENT_ID, expanded : thisExp, leaf : false}; 
                this.assignMembers(fldListArr, temptree, child);

                childList.push(temptree);
                tree["children"] = childList;
                this.createTreeStructure(temptree, child, list, level+1, expLevel, fldListArr); // Recursively create tree structure for the child since children exist.
            }
        }
        result.push(tree);
        return result;

    },

    assignMembers: function(fldListArr, treeObj, child) {
        for (var i=0; i< fldListArr.length; i++) {
            treeObj[fldListArr[i][0]] = child[fldListArr[i][0]];
        }
    },

    getChildren: function(root, list, firstOnly) {
        var i=0, ln = list.length, result = [];
        for(i=0; i<ln;i++)
        {
            if(root.ID===list[i].PARENT_ID)
            {
                result.push(list[i]);
                if (firstOnly) {return result;} // Only checking if single child exists so abort upon first detection
            }
        }
        return result;
    },

    hideShowPanels: function() {
        // Controls display of panels when phone is in landscape vs portrait orientation to
        //provide more realestate for scrolling the data

        var device = ((Ext.os.is.Phone) ? 'phone' : 'tablet');
        var orient = ((Ext.Viewport.getWindowWidth() > Ext.Viewport.getWindowHeight()) ? 'landscape' : 'portrait');

        if (device !== 'phone') {return;}

        // Call funciton to hide/show titlebar and bottom tabbar when in landscape mode, but only if
        // active window contains TouchGridPanel with active expand/collapse toolbar
        var currItem = Ext.Viewport.down('#maintabpanel').getActiveItem();

        var collapseBar, projex=false;
        if (currItem.getItemId() === 'projecttab') {
            // Project example contained within sub tab panel so need to get active item of that 
            projex=true;
            collapseBar = currItem.down('#projecttabpanel').getActiveItem().down('#touchtreegridbuttons');
        } else
        {    
            collapseBar = currItem.down('#touchtreegridbuttons');
        }    

        if (!collapseBar) {return;}

        var hide = (orient === 'landscape');

        // Hide bottom tabbar and titlebar for phones in landscape mode ... show in portrait mode
        var main = this.getMain();

        main.down('#maintitlebar').setHidden(hide);
        main.down('#maintabbar').setHidden(hide);

        // I could add logic for Project tab to add this for each tab in event user tabs to different example
        // if (projex) {....} else {...}
        collapseBar.down('#touchtreegridlabel').setHtml(hide ? 'Rotate for Menu' : '');
        collapseBar.down('#touchtreegridicon').setHidden(!hide);


    },

    loadStore: function(me, gridcont, gridurl, loadmask, loadStoreInPostProcess) {
        // Load TreeStore data from JSON file within Controller since doesn't seem to work from within Store itself.
        // NOTE:  autoload=true -and- dummy root initialization required in Store to work=>
        //     root: {children: []}
        // Also:  Regular stores in JSON file format seem to load from within Store without issue.

        if (loadmask) {
            Ext.Viewport.setMasked({
                xtype: 'loadmask',
                message: loadmask
            });
        }

        var myRequest = Ext.Ajax.request({
            url: gridurl,
            method: 'GET',
            timeout: 10000,
            cache: false,
            dataType: 'json',
            reader:{
                type: 'json'
            },

            success: function(response) {
                var griddata = Ext.JSON.decode(response.responseText);

                var gridListItemId = gridcont.getListItemId();
                var gridlist = gridcont.down('#'+gridListItemId);
                var gridstore = gridlist.getStore();

                if (!loadStoreInPostProcess) {
                    gridstore.suspendEvents();      
                    gridstore.removeAll();
                    var gridloaded = gridstore.setData(griddata);  
                    // setRoot() not working for TreeStores => http://www.sencha.com/forum/showthread.php?242257
                    gridstore.resumeEvents();
                    if (loadmask) {Ext.Viewport.setMasked(false);}
                }            

                commonController.postLoadProcess(gridListItemId, gridcont, griddata); 

            },

            failure: function(response, opts) {
                if (loadmask) {Ext.Viewport.setMasked(false);}

                Ext.Msg.alert('Data not loaded: '+gridurl);     
            }
        });

    },

    loadDynamicStore: function(me, gridcont, gridurl, loadmask, loadStoreInPostProcess) {

        if (loadmask) {
            Ext.Viewport.setMasked({
                xtype: 'loadmask',
                message: loadmask
            });
        }

        var myRequest = Ext.Ajax.request({
            url: gridurl,
            method: 'GET',
            timeout: 10000,
            cache: false,
            dataType: 'json',
            reader:{
                type: 'json'
            },

            success: function(response) {
                var alldata = Ext.JSON.decode(response.responseText);
                var griddata             = alldata.datalist;
                var columnsPhonePortrait = alldata.columnsPhonePortrait;
                var fields               = alldata.fields;

                // NOTE:  Could load different device and orienation column configurations
                //        and apply based on device/orientation here .. and update again
                //        within onOrientationChange().  If you load multiple configurations
                //        It is suggested that you store each of the column arrays to gridcont
                //        component for easy retrieval when switching.  
                //
                //        Ex:  gridcont.columnsPhonePortrait = columnsPhonePortrait;
                //             gridcont.columnsTabletLandscape = columnsTabletLandscape;
                //             etc...
                //
                //        Simply by calling doRefreshList() method after updating columns your 
                //        grid will immediately reflect the new column configuration.
                //
                //        Could support customized user preferences in this same way.

                var gridListItemId = gridcont.getListItemId();
                var gridlist = gridcont.down('#'+gridListItemId);

                gridcont.setColumns(columnsPhonePortrait);

                // Note: we are defining fields directly within Store instead of creating Model
                var gridstore = Ext.create('Ext.data.Store', {fields: fields});

                gridlist.setStore(gridstore);

                if (!loadStoreInPostProcess) {
                    gridstore.suspendEvents();      
                    var gridloaded = gridstore.add(griddata);  
                    gridstore.resumeEvents();
                    if (loadmask) {Ext.Viewport.setMasked(false);}
                }            

                commonController.postLoadProcess(gridListItemId, gridcont, griddata); 

            },

            failure: function(response, opts) {
                if (loadmask) {Ext.Viewport.setMasked(false);}

                Ext.Msg.alert('Data not loaded: '+gridurl);     
            }
        });

    },

    postLoadProcess: function(gridListItemId, gridcont, griddata) {
        var refreshed, fldListArr = [], collapseLvl, gridlist, scroller;

        gridlist = gridcont.down('#'+gridListItemId);
        scroller = gridlist.getScrollable().getScroller();

        if (gridListItemId === 'censusmainelist') {
            // Collapse nodes to defined level
            var depth = gridcont.getDefaultCollapseLevel();
            if (depth !== 99) {gridcont.doExpandDepth(depth);}

            censusController.loadColumnsCensusMaine(); // also refreshes list
        }
        else if ((gridListItemId ==='example2list') ||
        (gridListItemId ==='example2Blist') ||
        (gridListItemId ==='example2Clist')) {
            if (gridListItemId ==='example2list') {
                Ext.Msg.alert('Custom Expand levels!'); 
            }

            projectController.getProjectContainer().down('#example2list').up('touchtreegrid').doRefreshList();
            projectController.getProjectContainer().down('#example2Blist').up('touchtreegrid').doRefreshList();
            projectController.getProjectContainer().down('#example2Clist').up('touchtreegrid').doRefreshList();

            // workaround to get Touch 2.2 pullrefresh plugin to auto-snapBack
            scroller.scrollTo(0,1);
        }
        else if (gridListItemId === 'dow2012grouper2list') {

            // For each field define level "up to which" values will be included on category rows.
            // '0' means highest root row will include non-nullable values (or as defined in flat file) for this field.
            // '1' means level 1 categories will include data (if defined)
            // '2' means data will only be included for up to level 2.  Level 1 and root will not show data for this column.
            // etc...
            fldListArr = [['CloseDate', 1], ['Open', 1], ['High', 1], ['Low', 1], ['Close', 1],
            ['Volume', 1], ['AdjClose', 1], ['Chg', 1], ['ChgPct', 1], ['YearMonth', 0],
            ['grouper', 0]]; 

            collapseLvl = (Ext.isEmpty(gridcont.collapseLevel) ? 1 : gridcont.collapseLevel);
            // Refer to expCollapse() method where collapseLevel could be updated for manual expand processing

            commonController.loadTree(collapseLvl, griddata.datalist, fldListArr, gridcont, null); // collapse on initial load

            // Sort by YearMonth, then CloseDate
            gridlist.getStore().sort([{property: 'YearMonth', direction: 'DESC'},
            {property: 'CloseDate', direction: 'DESC'}]);

            Ext.Viewport.setMasked(false);
        }

        else if (gridListItemId === 'dow2012Dynamiclist') {
            refreshed = gridcont.doRefreshList(); 

            Ext.Msg.alert('Server defined Grid!');
        }

        else {
            refreshed = gridcont.doRefreshList(); 

        }
    },

    init: function(application) {
        /* Global object variables available throughout application */
        commonController = this.getApplication().getController('TouchTreeGrid.controller.CommonController');
        tasksController = this.getApplication().getController('TouchTreeGrid.controller.TasksController');
        projectController = this.getApplication().getController('TouchTreeGrid.controller.ProjectController');
        censusController = this.getApplication().getController('TouchTreeGrid.controller.CensusController');
        listsController = this.getApplication().getController('TouchTreeGrid.controller.ListsController');


    },

    launch: function() {
        /* Global variable to define current Touch version 2.1 vs. 2.2 */
        touchVersion = '2.2';

        /* Hack to look to see if setInfinite() function exists on one of the grids as means to determine framework version .. not sure if more direct method exists or not */
        var listcont = listsController.getListscontainer();
        var grp2cont = listcont.down('#dow2012grouper2Cont');
        var grp2grid = grp2cont.down('#dow2012grouper2list');


        if (typeof grp2grid.setInfinite != 'function') {  /* if not found then we are running 2.1 framework */
            touchVersion = '2.1';
        }


        if (touchVersion === '2.2') {
            /* Temporary code to hide Grouper2 example due to Touch 2.2 bug .. works under Touch 2.1 framework */
            var tab = listcont.down('#liststabpanel');
            tab.remove(grp2cont);
        } else {


        }

    }

});