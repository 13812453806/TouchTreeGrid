/*
 * File: app/view/CalendarPicker.js
 *
 * This file was generated by Sencha Architect version 2.2.2.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.2.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.2.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('CalendarPicker.view.CalendarPicker', {
    extend: 'Ext.Container',
    alias: 'widget.calendarpicker',

    config: {
        backMonths: 3,
        forwardMonths: 3,
        title: 'Select Date',
        lastSelectedDate: '',
        disableWeekends: false,
        disableHolidays: false,
        disableFutureDates: false,
        disablePastDates: false,
        includeFooter: true,
        singleExpand: false,
        disableExpandCollapse: false,
        variableHeights: false,
        categDepthColors: true,
        customExpCollapseEvent: 'monthExpCollapse',
        defaultCollapseLevel: 99,
        itemHeight: 32,
        selectMode: 'SINGLE',
        reverseSort: false,
        includeCustomFooterItems: false,
        useIconsForExpCollapse: true,
        autoCollapseMonthsPriorToMinSelDt: false,
        hideTitleBar: false,
        autoExpandMonthsWithSelDates: true,
        footerDock: 'bottom',
        hideExpandCollapseBtns: false,
        enableQuickDaySelection: false,
        includeCustomDatesLegend: false,
        allowMonthAdditions: false,
        monthsToInsert: 3,
        monthsToAppend: 3,
        monthsToAppendText: 'Append more Months...',
        monthsToInsertPullText: 'Pull to Insert Months...',
        monthsToInsertRefreshText: 'Release to Insert Months...',
        expandCurrentMonth: true,
        monthNodeHeightInPixels: 32,
        matrixView: false,
        matrixRows: 99,
        matrixCols: 3,
        disableListScroll: false,
        matrixItemHeight: '13.5em',
        customDatesLegendScrollDock: 'fixed',
        allowMatrixMonthAdditions: false,
        matrixItem6WeekHeight: '15em',
        cls: 'x-touchtreegrid-list-calendar',
        itemId: 'calendarpicker',
        hideOnMaskTap: false,
        layout: {
            type: 'fit'
        },
        modal: false,
        columns: [
            {
                dataIndex: 'dow0',
                width: '14.285%',
                addDataIndexToDiv: true,
                css: '{[this.cls_renderer_dates(\'dow0\', values)]}',
                renderer: 'this.renderer_dates(\'dow0\', values)'
            },
            {
                dataIndex: 'dow1',
                width: '14.285%',
                addDataIndexToDiv: true,
                css: '{[this.cls_renderer_dates(\'dow1\', values)]}',
                renderer: 'this.renderer_dates(\'dow1\', values)'
            },
            {
                dataIndex: 'dow2',
                width: '14.285%',
                addDataIndexToDiv: true,
                css: '{[this.cls_renderer_dates(\'dow2\', values)]}',
                renderer: 'this.renderer_dates(\'dow2\', values)'
            },
            {
                dataIndex: 'dow3',
                width: '14.285%',
                addDataIndexToDiv: true,
                css: '{[this.cls_renderer_dates(\'dow3\', values)]}',
                renderer: 'this.renderer_dates(\'dow3\', values)'
            },
            {
                dataIndex: 'dow4',
                width: '14.285%',
                addDataIndexToDiv: true,
                css: '{[this.cls_renderer_dates(\'dow4\', values)]}',
                renderer: 'this.renderer_dates(\'dow4\', values)'
            },
            {
                dataIndex: 'dow5',
                width: '14.285%',
                addDataIndexToDiv: true,
                css: '{[this.cls_renderer_dates(\'dow5\', values)]}',
                renderer: 'this.renderer_dates(\'dow5\', values)'
            },
            {
                dataIndex: 'dow6',
                width: '14.285%',
                addDataIndexToDiv: true,
                css: '{[this.cls_renderer_dates(\'dow6\', values)]}',
                renderer: 'this.renderer_dates(\'dow6\', values)'
            }
        ],
        categColumns: [
            {
                dataIndex: 'month',
                width: '100%',
                categCss: 'calendarpicker-month',
                renderer: 'this.renderer_month(values)'
            }
        ],
        renderers: {
            renderer_month: function (values)
           {return values.month + ' ' + values.year;},
            renderer_dates: function (fldName, values) {
           var elem=values[fldName];
           return elem;},
            cls_renderer_dates: function (fldName, values)
         {var cls="", dt, sel, hol, dis, par = this.scope.parent, cust;
          dt = values['dt_'+fldName];
          hol = values['isHoliday_'+fldName];
          dis = values['isDisabled_'+fldName];
          cust = values['customCls_'+fldName];
        
          if (values.rowType === 'H') {
             cls = cls + ' calendarpicker-header';}  
          else if (Ext.isEmpty(dt)) {} // do nothing for empty dates
          else {
             sel = (par.getSelDtArr().indexOf(Ext.Date.format(dt, 'Y-m-d'))>-1);
             if (Ext.Date.format(dt, 'w')==='0' || Ext.Date.format(dt, 'w')==='6') {
               cls = cls+' calendarpicker-weekend';
             }   
             if (hol){cls = cls+' calendarpicker-holiday';}
             if (!Ext.isEmpty(cust)) {cls = cls + ' ' + cust;}
             if (!Ext.isEmpty(this.scope.todayDt)){
               if (this.scope.todayDt === Ext.Date.format(dt, 'Y-m-d')) {
                  cls = cls+' calendarpicker-today';
               }
             }     
             if (dis){cls = cls+' calendarpicker-disabled';}
             if (sel){cls = cls+' calendarpicker-selected';}
          }
         
         return ("calendarpicker-days" + cls);
         }
        },
        selDtArr: [
            
        ],
        holidayDtArr: [
            
        ],
        disableDtArr: [
            
        ],
        customDtArr: [
            
        ],
        categDepthColorsArr: [
            'transparent',
            'transparent',
            'transparent'
        ],
        comments: [
            'selectMode = MULTI, SINGLE, RANGE, NONE'
        ],
        filter: {
            
        },
        customFooterItems: {
            xtype: 'segmentedbutton',
            itemId: 'pickerfooterbtns',
            docked: 'right',
            items: [
                {
                    xtype: 'button',
                    text: 'DONE',
                    iconCls: '',
                    cls: 'pickerfooterbtns',
                    listeners: {
                        tap: function (button, e, options) {
                           this.up('calendarpicker').customBtns('DONE');
                         }
                    }
                },
                {
                    xtype: 'button',
                    text: 'Clear',
                    cls: 'pickerfooterbtns',
                    listeners: {
                        tap: function (button, e, options) {
                           this.up('calendarpicker').customBtns('CLEAR');
                          }
                    }
                },
                {
                    xtype: 'button',
                    text: 'Cancel',
                    iconCls: '',
                    cls: 'pickerfooterbtns',
                    listeners: {
                        tap: function (button, e, options) {
                           this.up('calendarpicker').customBtns('CANCEL');
                          }
                    }
                }
            ]
        },
        returnItem: {
            
        },
        customCls: [
            
        ],
        customDateTypes: [
            {
                customType: 'default',
                customDescr: 'Custom',
                useCustomDtArr: true,
                storeId: null,
                priority: 1,
                disabled: false,
                cls: 'customDates-default'
            }
        ],
        matrixContainer: {
            
        },
        items: [
            {
                xtype: 'touchtreegrid',
                store: '',
                listScrollable: true,
                contentItemTpl: '',
                list: {
                    
                },
                disableSelection: true,
                onItemDisclosure: false,
                columns: [
                    
                ],
                header: {
                    xtype: 'toolbar',
                    docked: 'top',
                    cls: 'touchtreegrid-header',
                    maxHeight: '1.8em',
                    minHeight: '1.8em'
                },
                headerTpl: '',
                variableHeights: false,
                itemHeight: 32,
                disclosureProperty: 'disclose',
                listItemId: 'calendarlist',
                categItemTpl: '',
                footer: {
                    xtype: 'toolbar',
                    docked: 'bottom',
                    ui: 'light',
                    cls: 'touchtreegrid-footer',
                    itemId: 'calendarFooter'
                },
                includeFooter: true,
                listPlugins: {
                    
                },
                categIndentPct: '0',
                colNumberToTruncateForIndents: 1,
                includeFooterLevels: true,
                categDepthColors: true,
                categDepthColorsArr: [
                    'transparent',
                    'transparent',
                    'transparent'
                ],
                renderers: {
                    
                },
                categDepthColorButtons: true,
                categItemTplOverride: '',
                contentItemTplOverride: '',
                headerTplOverride: '',
                includeHeader: false,
                applyDefaultCollapseLevel: true,
                defaultCollapseLevel: 1,
                landscapeIcon: '',
                helpHtml: '',
                pressedCls: 'touchtreegrid-item-pressed',
                simpleList: false,
                columnSorting: false,
                styleCategRow: '',
                styleHeaderRow: '',
                singleExpand: false,
                additionalListConfigs: {
                    
                },
                selectedCls: 'touchtreegrid-item-selected',
                mode: 'SINGLE',
                useSimpleItems: true,
                infinite: true,
                arrowPctWidth: '0',
                disableExpandCollapse: false,
                categColumns: [
                    
                ],
                categCssArr: [
                    
                ],
                cssContentRow: 'css-content-row{[values.rowType === \'H\' ? \' calendarpicker-header-rowtype\' : \'\']}',
                cssCategRow: 'css-categ-row',
                cssHeaderRow: 'css-header-row',
                customFooterItems: {
                    
                },
                includeCustomFooterItems: false,
                footerDock: 'bottom',
                hideExpandCollapseBtns: false,
                cls: [
                    'x-touchtreegrid-list',
                    'x-touchtreegrid-list-calendar'
                ],
                itemId: 'calendar',
                layout: {
                    type: 'vbox'
                }
            }
        ]
    },

    initialize: function() {
        this.callParent();


        var me = this, i, newCls, newCls2;

        var gridcont = this.down('#calendar');
        var gridlist = this.down('#calendarlist');
        var scroller = gridlist.getScrollable().getScroller();

        // Store primary components with CalendarPicker component for faster reference
        me.gridcont = gridcont;
        me.gridlist = gridlist;
        me.scroller = scroller;

        var tempstore = gridlist.getStore(); // Created when TouchTreeGrid is instantiated without a store reference
        if (!Ext.isEmpty(tempstore)) {
            Ext.data.StoreManager.unregister(tempstore); // remove from store manager
        }

        if (me.getMatrixView()) {
            me.matrixPrep(me.config);
            return;
        }

        var matrixItem = me.config.matrixItem;  // would be undefined for non-Matrix implementations

        var titleBar, legend;  // Only add if needed
        if (!me.getHideTitleBar()) {
            titleBar = {
                xtype: 'toolbar',
                cls: 'calendarpicker-toolbar',
                docked: 'top',
                itemId: 'calendarpicker-toolbar',
                ui: 'plain',
                title: me.getTitle()
            };
            me.add(titleBar);
        }    

        var customDatesLegendScrollDock = me.getCustomDatesLegendScrollDock();
        if (me.getIncludeCustomDatesLegend()) {

            legend =   {
                xtype: 'component',
                cls: 'calendarpicker-legend',
                html: '',
                itemId: 'calendarpicker-legend'
            };


            // If Matrix View only want to add for first month in sequence
            if (!Ext.isEmpty(matrixItem)) {
                if (me.config.seq === 0 )  {   
                    var matrixContainer = matrixItem.getMatrixContainer();
                    if (!Ext.isEmpty(matrixContainer))  {
                        var customMatrixCls = matrixItem.getCustomCls().join(' ');  
                        legend.cls = customMatrixCls + ' ' + legend.cls;      // Prefix with CLS for initializing Matrix container for constistent styling application                            
                        legend.docked = 'top';                
                        matrixContainer.add(legend);
                        me.legend = matrixContainer.down('#calendarpicker-legend');  // save for createStore()
                    }
                }
            } else {
                if (customDatesLegendScrollDock === 'top') {
                    legend.scrollDock = 'top';      // dock to scrolling list at top
                    gridlist.add(legend);
                }
                else if (customDatesLegendScrollDock === 'bottom') {
                    legend.scrollDock = 'bottom';  // dock to scrolling list at bottom
                    gridlist.add(legend);
                }
                else if (customDatesLegendScrollDock === 'both') {
                    legend.scrollDock = 'top';      // dock to scrolling list at top
                    gridlist.add(legend);

                    legend.scrollDock = 'bottom';  // also dock to scrolling list at bottom
                    legend.itemId = 'calendarpicker-legend2';
                    gridlist.add(legend);
                    me.legend2 = me.down('#calendarpicker-legend2');  // save for createStore()            
                }        
                else {
                    legend.docked = 'top';
                    me.add(legend);  // add to container and dock to top
                }

                me.legend = me.down('#calendarpicker-legend');  // save for createStore()
            }
        }



        // Pass common configs from CalendarPicker component to underlying TouchTreeGrid component
        gridcont.setCategColumns(me.getCategColumns());
        gridcont.setColumns(me.getColumns());
        gridcont.setRenderers(me.getRenderers());

        gridcont.setIncludeFooter(me.getIncludeFooter());
        gridcont.setSingleExpand(me.getSingleExpand());
        gridcont.setDisableExpandCollapse(me.getDisableExpandCollapse());
        gridcont.setCategDepthColors(me.getCategDepthColors());
        gridcont.setCustomExpCollapseEvent(me.getCustomExpCollapseEvent());
        gridcont.setVariableHeights(me.getVariableHeights());
        gridcont.setDefaultCollapseLevel(me.getDefaultCollapseLevel());
        gridcont.setCategDepthColorsArr(me.getCategDepthColorsArr());
        gridcont.setItemHeight(me.getItemHeight());
        gridcont.setFooterDock(me.getFooterDock());
        gridcont.setHideExpandCollapseBtns(me.getHideExpandCollapseBtns());

        // Version 2 Mods
        gridlist.setVariableHeights(me.getVariableHeights());
        gridlist.setItemHeight(me.getItemHeight());


        // Save original state of selections in case of clear or cancel
        var selDtArr = me.getSelDtArr();
        me.origSelDtArr = (Ext.isEmpty(selDtArr) ? [] : selDtArr);

        gridcont.setCustomFooterItems(me.getCustomFooterItems());
        gridcont.setIncludeCustomFooterItems(me.getIncludeCustomFooterItems());

        var customCls=me.getCustomCls();
        if (!Ext.isEmpty(customCls)) {
            newCls = gridcont.getCls().slice(0);  // need to clone and setCls() below to work correctly
            newCls2 = me.getCls().slice(0);  // also updating CLS for Calendar Picker

            for (i=0; i<customCls.length; i++) {
                if ((newCls.indexOf(customCls[i])===-1)) {
                    newCls.push(customCls[i]);
                }
                if ((newCls2.indexOf(customCls[i])===-1)) {
                    newCls2.push(customCls[i]);
                }        
            }

            gridcont.setCls(newCls);
            me.setCls(newCls2); 
        }

        // Deal with race-condition where footer is applied even though calling routine requests not to
        var myFooter = this.down('#touchtreegridbuttons');
        var myFooterExpCollHide = this.down('#touchtreegridsegmentedbuttons');
        if (!Ext.isEmpty(myFooterExpCollHide) && this.getHideExpandCollapseBtns()) {
            myFooterExpCollHide.destroy();
        }
        if (myFooter.getDocked() !== this.getFooterDock()) {
            myFooter.setDocked(this.getFooterDock());
        }
        if (!Ext.isEmpty(myFooter) && !this.getIncludeFooter()) {
            myFooter.destroy();
        }

        if (this.getIncludeFooter() && this.getUseIconsForExpCollapse()) {
            /* shrink exp/collapse button widths by using arrow icons */
            var exp = gridcont.down('#touchtreegridexpand');
            if (!Ext.isEmpty(exp)) {
                exp.setText('');
                exp.setIconCls('arrow_down');
                exp.setPadding(0);
            }
            var col = gridcont.down('#touchtreegridcollapse');
            if (!Ext.isEmpty(col)) {
                col.setText('');
                col.setIconCls('arrow_up');
                col.setPadding(0);
            }
        }


        var monthsToInsert = me.getMonthsToInsert();
        var monthsToAppend = me.getMonthsToAppend();
        if (me.getAllowMonthAdditions() && monthsToInsert>0 ) {
            // Update listPlugins such that PullRefresh auto-adds 
            gridlist.setPlugins({
                xclass: 'Ext.plugin.PullRefresh',
                pullRefreshText: me.getMonthsToInsertPullText(),
                releaseRefreshText: me.getMonthsToInsertRefreshText(),
                listeners: {
                    latestfetched: function() {this.up('calendarpicker').fireEvent('insertMonths', this.up('calendarpicker'));}
                }
            });
        }

        if (me.getAllowMonthAdditions() && monthsToAppend>0) {
            // Add Load More button at bottom of list 

            gridlist.add({
                xtype: 'component',
                html: me.getMonthsToAppendText(),
                cls: 'months-to-append-html',
                scrollDock: 'bottom',
                listeners: {
                    tap: {
                        fn: me.onAppendMonths,
                        scope: me,
                        element: 'element'
                    }        
                }
            });
        }

        me.createStore(me, gridcont, gridlist);


        // Handle leafItemTap event from TouchTreeGrid for day selection processing
        gridcont.on('leafItemTap', me.onLeafItemTap, me);


        // Add listener when this component is destroyed to also destroy associated Store
        me.on('destroy', me.onDestroy, me);



        if (!me.getMatrixView()) {
            // Add listener for Pull to Add Months event
            if (me.getAllowMonthAdditions()) {
                me.on('insertMonths', me.onInsertMonths, me);
            }    

            // Handle monthExpCollapse event from TouchTreeGrid for rapid expand/collapse
            gridcont.on('monthExpCollapse', me.onExpCollapse, me);

            // Add listener for when list is shown to then scroll to designated node    
            scroller.on('refresh',  me.onScrollerRefresh, me);
        }




    },

    matrixPrep: function(parentConfig, addMode) {
        var me = this, i, j;

        //Copy parentConfig to keys and values arrays
        var keys = Ext.Object.getKeys(parentConfig); 
        var values = Ext.Object.getValues(parentConfig);

        var matrixCols = me.getMatrixCols();
        var matrixRows = me.getMatrixRows();
        var monthsToAppend = me.getMonthsToAppend();
        var matrixContainer = me.getMatrixContainer(); 
        var parItemId = me.getItemId();
        var matrixItemHeight = me.getMatrixItemHeight();
        var matrixItem6WeekHeight = me.getMatrixItem6WeekHeight();
        matrixItem6WeekHeight = (Ext.isEmpty(matrixItem6WeekHeight) ? matrixItemHeight : matrixItem6WeekHeight);



        var skipKeys = ['control', 'layout', 'comments', 'filter', 'items', 'itemId',
            'columns', 'categColumns',
            'matrixView', 'matrixCols', 'matrixRows', 'matrixContainer',
            'returnItem', 'backMonths', 'forwardMonths','disableExpandCollapse',
            'selectMode', 'defaultCollapseLevel', 'hideTitleBar', 'includeFooter'];

        var calendarKeys = {  
            //  xtype: 'calendarpicker',
            flex: 1,
            //  layout: {type: 'fit'},  
            selectMode: 'NONE',
            defaultCollapseLevel: 99,
            disableExpandCollapse: true,
            hideTitleBar: true,
            includeFooter: false,
            disableListScroll: true
        };

        // Build Calendar instance object
        for (i=0; i<keys.length; i++) {
            if (skipKeys.indexOf(keys[i]) === -1) {  // ignore if in skipKeys[]
                calendarKeys[keys[i]] = values[i];
            }
        }

        if (matrixContainer.getLayout().config.type !== 'fit') {
            console.log(matrixContainer);
            console.log('Container must be of type fit');
            Ext.Msg.alert('Matrix Container must be of type fit');
            return;
        }

        var thisRow, rowArr=[], items, customCls, thisCls, matrixItems=[], thisFirstDt, thisYearMonth, numRows,
            numRowsPrior=0, numItemsPrior=0;

        var backMoInp = me.getBackMonths(), fwdMoInp = me.getForwardMonths();
        var backMo=Ext.isEmpty(backMoInp) ? 0 : backMoInp;  // allow negatives to support future start months
        var fwdMo=Ext.isEmpty(fwdMoInp) ? 0 : fwdMoInp;


        var totMonths = fwdMo + backMo;

        if (addMode) { // Increment new ForwardMonths value and range
            backMo = (-1*fwdMo);  
            fwdMo = fwdMo + monthsToAppend;
            me.setForwardMonths(fwdMo);  // Save new value to component 

            totMonths = monthsToAppend; // override for addMode

            matrixItems = me.matrixItems;
            numItemsPrior = me.currentNumItems;
            numRowsPrior = me.currentMatrixRows;    
        } 

        var today= Ext.Date.clearTime(new Date(Date(Ext.Date.now())), true);
        var firstdt = Ext.Date.clearTime(Ext.Date.getFirstDateOfMonth(today), true);

        // Loop for each month and render independently in Matrix View
        thisRow = 0;
        i=0;  // initialize
        do {
            // Insert row of containers 
            items=[];
            for (j=0; j<matrixCols; j++) {
                thisMo = backMo - i;   //  3 to 6: backMo iterates as  3, 2, 1, 0, -1, -2, -3, -4, -5, -6
                // -3 to 6: backMo iterates as -3, -4, -5, -6
                thisFirstDt = Ext.Date.clearTime(Ext.Date.add(firstdt, Ext.Date.MONTH, -1*thisMo), true);
                thisYearMonth = Ext.Date.format(thisFirstDt, 'Y')+Ext.Date.format(thisFirstDt, 'm');

                if (i>=totMonths) {
                    matrixItems.push({
                        xtype: 'container',
                        itemId: parItemId+'_'+(numItemsPrior + i).toString(),
                        layout: {type: 'fit'},
                        flex: 1,
                        row:  numRowsPrior + thisRow,
                        col: j,
                        seq: numItemsPrior + i,
                        cls: 'calendarpicker-matrix-item ' + (j===matrixCols-1 ? 'matrix-column-last' : 'matrix-column') +' matrix-column-empty',
                        yearMonth: thisYearMonth
                    });

                } else {
                    customCls = me.getCustomCls().join(' ');  
                    thisCls = customCls + ' calendarpicker-matrix-item ' + (j===matrixCols-1 ? 'matrix-column-last' : 'matrix-column');

                    matrixItems.push({
                        xtype: 'calendarpicker',
                        itemId: parItemId+'_'+(numItemsPrior + i).toString(),
                        // each calendar will have unique ID beginning with parent itemId suffixed with calendar sequence            
                        row:  numRowsPrior + thisRow,
                        col: j,
                        seq: numItemsPrior + i,
                        cls: thisCls,
                        backMonths: thisMo,
                        forwardMonths: -1*thisMo,
                        yearMonth: thisYearMonth
                    });
                }
                i++;
            }
            rowArr.push({
                xtype: 'container',
                cls: (i>=totMonths ? 'matrix-row-last' : 'matrix-row'),
                minHeight: matrixItemHeight,
                maxHeight: matrixItemHeight,
                height: matrixItemHeight,
                width: '100%',

                layout: {type: 'hbox'},
                row:  numRowsPrior + thisRow,
                itemId: 'matrixRow_'+(numRowsPrior + thisRow).toString()
            });

            thisRow++;
            if (thisRow >= matrixRows) {break;} // don't insert more rows than requested

        } while (i<totMonths);
        numRows = thisRow--;

        // Store matrixItems[] with parent component for other uses
        me.matrixItems = matrixItems; 
        me.currentMatrixRows = numRowsPrior + numRows;
        me.currentNumItems = numItemsPrior + totMonths;


        if (me.getAllowMatrixMonthAdditions() && addMode) {  // Remove and add back to simplify addition of matrix items
            matrixContainer.down('#calendarpicker-matrix-add').destroy();
        }

        if (addMode) {
            // Insert rows after prior set 
            matrixContainer.down('#'+parItemId+'_matrix').add(rowArr);
        } else {    

            matrixContainer.add({
                xtype: 'container',
                itemId: parItemId+'_matrix',
                scrollable: 'vertical',
                cls: 'calendarpicker-matrix',
                layout: 'default',
                items: rowArr
            });
        }    

        // Need to add grid items after parent containers have been instantiated to work correctly
        var thisRowItem, thisItem, getDts;
        k=0+numItemsPrior;
        for (i=0; i<numRows; i++) {

            thisRowItem=matrixContainer.down('#'+rowArr[i].itemId);
            for (j=0; j<matrixCols; j++) {

                if (matrixItems[k].xtype === 'container') {
                    thisRowItem.add(matrixItems[k]);
                }
                else if (matrixItems[k].xtype === 'calendarpicker') {
                    calendarKeys['cls']           = matrixItems[k].cls;
                    calendarKeys['backMonths']    = matrixItems[k].backMonths;
                    calendarKeys['forwardMonths'] = matrixItems[k].forwardMonths;
                    calendarKeys['itemId']        = matrixItems[k].itemId; 
                    calendarKeys['matrixItem']    = me;  
                    calendarKeys['yearMonth']     = matrixItems[k].yearMonth;  
                    calendarKeys['row']           = matrixItems[k].row;             
                    calendarKeys['col']           = matrixItems[k].col;             
                    calendarKeys['seq']           = matrixItems[k].seq;    

                    getDts = Ext.create('widget.calendarpicker', calendarKeys);
                    if (getDts.numWeeks === 6) {
                        thisRowItem.setMaxHeight(matrixItem6WeekHeight);
                        thisRowItem.setMinHeight(matrixItem6WeekHeight);
                        thisRowItem.setHeight(matrixItem6WeekHeight);
                    }
                    thisRowItem.add(getDts);
                }
                k++;
            }
        }



        // Add listener to Add Months event
        if (me.getAllowMatrixMonthAdditions()) {
            matrixContainer.down('#'+parItemId+'_matrix').add({
                xtype: 'titlebar',
                cls: 'calendarpicker-matrix-add',
                itemId: 'calendarpicker-matrix-add',
                ui: 'plain',
                title: me.getMonthsToAppendText(),
                listeners: {
                    tap: {
                        fn: me.onAppendMatrixMonths,
                        scope: me,
                        element: 'element'
                    }        
                }       
            });  

        }   

    },

    createStore: function(me, gridcont, gridlist, expandCollapse) {
        var backMoInp = me.getBackMonths(), fwdMoInp = me.getForwardMonths();


        var backMo=Ext.isEmpty(backMoInp) ? 0 : backMoInp;  // allow negatives to support future start months
        var fwdMo=Ext.isEmpty(fwdMoInp) ? 0 : fwdMoInp;

        var selDtArr = me.getSelDtArr();
        var holidayDtArr = me.getHolidayDtArr();
        var disableDtArr = me.getDisableDtArr();
        var disableFutureDates = me.getDisableFutureDates();
        var disableHolidays = me.getDisableHolidays();
        var disableWeekends = me.getDisableWeekends();
        var disablePastDates = me.getDisablePastDates();


        var today= Ext.Date.clearTime(new Date(Date(Ext.Date.now())), true);
        var currMonth = Ext.Date.format(today, 'm');
        var currYear = Ext.Date.format(today, 'Y');

        gridcont.todayDt = Ext.Date.format(today, 'Y-m-d');

        var firstdt = Ext.Date.clearTime(Ext.Date.getFirstDateOfMonth(today), true);

        var startFirstDt = Ext.Date.clearTime(Ext.Date.add(firstdt, Ext.Date.MONTH, -1*backMo), true);
        var endFirstDt = Ext.Date.clearTime(Ext.Date.add(firstdt, Ext.Date.MONTH, fwdMo), true);

        var endLastDt  = Ext.Date.clearTime(Ext.Date.getLastDateOfMonth(endFirstDt), true);

        var dateArr = [], done=false, dt=startFirstDt, dtStr, mo, moFullNm, yrNm, numDays,
            firstDayIdx, lastDayIdx, wk, i, j, k, m, n, id=0, parId, weekNum, wkArr=[], wkDtArr=[], moCnt=0,
            wkIsDisArr=[], wkIsHolArr=[], wkCustClsArr=[], wkCustHtmlArr=[], wkHolHtmlArr=[];

        // Process customDateTypes[]
        var customDateTypes = me.getCustomDateTypes();
        var customDtArr = me.getCustomDtArr();
        var customDtArrMod = [], storeId, store;
        var includeCustomDatesLegend = me.getIncludeCustomDatesLegend();
        var legend = me.legend;  // updated in initialize() for matrix for standard calendars
        var legendHtml='';

        var matrixItem = me.config.matrixItem;  // would be undefined for non-Matrix implementations


        // Only process custom dates from store for 1st calendar in Matrix if applicable
        if (!Ext.isEmpty(matrixItem) && me.config.seq > 0 )  {   
            customDtArrMod = matrixItem.customDtArrMod;
            disableDtArr   = matrixItem.disableDtArr;
        }
        else {  
            for (i=0; i<customDateTypes.length; i++) {

                if (customDateTypes[0].customType==='default' && customDateTypes[0].useCustomDtArr && customDtArr.length>0) {
                    // Use customDtArr[] as provided if default entry found in 1st index position and dates have been supplied in customDtArr[]
                    for (j=0; j<customDtArr.length; j++) {
                        customDtArrMod.push({customType: 'default', dateStr: customDtArr[j], descr: ''});
                        if (customDateTypes[0].disabled) {
                            disableDtArr.push(customDtArr[j]);
                        }                  
                    }
                    break;
                }

                // Else process one or more customDateTypes as defined in customDateTypes[] by building customDtArrMod[] for each customType 
                // Custom Dates must be provided from store 
                storeId = customDateTypes[i].storeId;
                store = Ext.data.StoreManager.getByKey(storeId);
                if (!Ext.isEmpty(store)){
                    // Loop through store and update customDtArrMod[] for matching rows for current customType
                    store.each(function (item, index, length) {
                        var htmlDescr = (Ext.isEmpty(item.get('descr')) ? '' : item.get('descr'));
                        if (item.get('customType')===customDateTypes[i].customType) {
                            customDtArrMod.push({customType: customDateTypes[i].customType, dateStr: item.get('dateStr'), descr: htmlDescr});
                            if (customDateTypes[i].disabled) {
                                disableDtArr.push(item.get('dateStr'));
                            }
                        }
                    });           
                }

                // Update HTML for Custom Dates Legend if applicable  (order of customType definition)
                legendHtml = legendHtml + (Ext.isEmpty(legendHtml) ? '' : '<br>') + 
                '<span class="'+customDateTypes[i].cls+' calendarpicker-legend-cls-override">&nbsp;</span><span class=" calendarpicker-legend-cls-html">'+customDateTypes[i].customDescr+'</span>';
            }

            if (!Ext.isEmpty(matrixItem))  {
                // Store arrays created for initial calendar for subseqent calendar processing
                matrixItem.customDtArrMod = customDtArrMod;
                matrixItem.disableDtArr = disableDtArr;
            }    
        }

        if (includeCustomDatesLegend && customDtArrMod.length>0 && !Ext.isEmpty(legend)) {
            // legend container only added once for first calendar in matrix ... see initialize() method
            legend.setHtml(legendHtml);
            if (!Ext.isEmpty(me.legend2)) {
                me.legend2.setHtml(legendHtml);  // optional bottom legend set in initialize()
            }
        }


        // Sort customDateTypes by descending priority when applying CLS
        // (priority 1 CLS overrides priority 2 if 2 custom dates must be rendered for same date)
        customDateTypes.sort(orderByPriorityDesc);

        // Sort function to sort CustomDateTypes[] array of objects by descending priority
        function orderByPriorityDesc(b, a) {
            if (a.priority == b.priority) {
                return 0;
            } else if (a.priority > b.priority) {
                return 1;
            }
            return -1;
        }

        do {    
            // Loop for each month
            mo=Ext.Date.format(dt, 'm');
            moFullNm = Ext.Date.format(dt, 'F');
            yrNm = Ext.Date.format(dt, 'Y');

            numDays = Ext.Date.getDaysInMonth(dt);
            firstDayIdx = Ext.Date.getFirstDayOfMonth(dt);
            lastDayIdx = Ext.Date.getLastDayOfMonth(dt); 
            firstDtIdx = Ext.Date.clearTime(Ext.Date.getFirstDateOfMonth(dt), true);
            lastDtIdx = Ext.Date.clearTime(Ext.Date.getLastDateOfMonth(dt), true); 

            // Insert node for current month
            dateArr.push({           
                month: moFullNm,
                mo: mo,
                year: yrNm,
                numDays: numDays,
                rowType: 'P',   // parent row type  
                ID: id,
                PARENT_ID: null
            });
            parId = id;

            moCnt++;
            id++;  // increment next id

            // add empty row type for start of month 
            dateArr.push(
            {           
                month: moFullNm,
                mo: mo,
                year: yrNm,
                numDays: numDays,
                rowType: 'H',   // header row type    
                ID: id,
                PARENT_ID: parId,
                dow0: 'Sun',
                dow1: 'Mon',
                dow2: 'Tue',
                dow3: 'Wed',
                dow4: 'Thu',
                dow5: 'Fri',
                dow6: 'Sat'
            }); 
            id++;  // increment next id 
            weekNum = 1;
            i = 1;
            do {  // Loop for all days in current month

                dtStr = Ext.Date.format(dt, 'Y-m-d');

                // Loop for each week of month
                for (j=0; j<=6; j++) {
                    if ((dtStr===Ext.Date.format(firstDtIdx, 'Y-m-d') && j<firstDayIdx) || 
                    (dtStr>=Ext.Date.format(lastDtIdx, 'Y-m-d') && j>lastDayIdx)) {
                        wkArr[j] = null;
                        wkDtArr[j] = null;
                        wkIsDisArr[j] = null;
                        wkIsHolArr[j] = null;
                        wkCustClsArr[j] = null;
                        wkCustHtmlArr[j] = null;
                        wkHolHtmlArr[j] = null;                
                    } else {
                        wkArr[j] = i;
                        wkDtArr[j] = dt;  
                        wkIsDisArr[j] = ((disableDtArr.indexOf(dtStr) !== -1) ||
                        (disableFutureDates && (dtStr > gridcont.todayDt) ) ||
                        (disableWeekends && (Ext.Date.format(dt, 'w')==='0' || Ext.Date.format(dt, 'w')==='6')) ||
                        (disableHolidays && (holidayDtArr.indexOf(dtStr)>-1) ) ||
                        (disablePastDates && (dtStr < gridcont.todayDt)));
                        wkIsHolArr[j] = (holidayDtArr.indexOf(dtStr) !== -1);

                        wkCustClsArr[j]='';   // Initialize
                        wkCustHtmlArr[j]='';  // Initialize
                        wkHolHtmlArr[j] = ''; // LATER                                

                        // Update Custom classes and Html for each overlapping date, by reverse priority
                        for (k=0; k<customDateTypes.length; k++) {
                            for (m=0; m<customDtArrMod.length; m++) {
                                if ( customDtArrMod[m].customType===customDateTypes[k].customType && 
                                dtStr === customDtArrMod[m].dateStr ) {
                                    wkCustClsArr[j]  = (!Ext.isEmpty(wkCustClsArr[j]) ? wkCustClsArr[j]+' ' : '')+customDateTypes[k].cls;
                                    wkCustHtmlArr[j] = (!Ext.isEmpty(wkCustHtmlArr[j]) ? wkCustHtmlArr[j]+'<br>' : '')+customDtArrMod[m].descr;                            
                                }
                            }                    
                        }

                        i++;  //Increment i
                        tmp = Ext.Date.clone(dt);  
                        dt = Ext.Date.add(tmp, Ext.Date.DAY, 1);  // next day
                        dtStr = Ext.Date.format(dt, 'Y-m-d');                                    
                        if (Ext.Date.format(tmp, 'Y-m-d')===dtStr) {
                            // Correct for day light savings changes where add() method only adds 23 hours
                            dt = Ext.Date.add(dt, Ext.Date.DAY, 1);  // next day
                            dtStr = Ext.Date.format(dt, 'Y-m-d');                    
                        }
                        Ext.Date.clearTime(dt);
                    }            
                }

                dateArr.push(
                {
                    month: moFullNm,
                    mo: mo,
                    year: yrNm,
                    numDays: numDays,
                    rowType: 'W',   
                    weekNum: weekNum,
                    ID: id,
                    PARENT_ID: parId,
                    dow0:  wkArr[0], dt_dow0: wkDtArr[0], isDisabled_dow0: wkIsDisArr[0], isHoliday_dow0: wkIsHolArr[0], customCls_dow0: wkCustClsArr[0], customHtml_dow0: wkCustHtmlArr[0], holidayHtml_dow0: wkHolHtmlArr[0],          
                    dow1:  wkArr[1], dt_dow1: wkDtArr[1], isDisabled_dow1: wkIsDisArr[1], isHoliday_dow1: wkIsHolArr[1], customCls_dow1: wkCustClsArr[1], customHtml_dow1: wkCustHtmlArr[1], holidayHtml_dow1: wkHolHtmlArr[1],           
                    dow2:  wkArr[2], dt_dow2: wkDtArr[2], isDisabled_dow2: wkIsDisArr[2], isHoliday_dow2: wkIsHolArr[2], customCls_dow2: wkCustClsArr[2], customHtml_dow2: wkCustHtmlArr[2], holidayHtml_dow2: wkHolHtmlArr[2],   
                    dow3:  wkArr[3], dt_dow3: wkDtArr[3], isDisabled_dow3: wkIsDisArr[3], isHoliday_dow3: wkIsHolArr[3], customCls_dow3: wkCustClsArr[3], customHtml_dow3: wkCustHtmlArr[3], holidayHtml_dow3: wkHolHtmlArr[3],    
                    dow4:  wkArr[4], dt_dow4: wkDtArr[4], isDisabled_dow4: wkIsDisArr[4], isHoliday_dow4: wkIsHolArr[4], customCls_dow4: wkCustClsArr[4], customHtml_dow4: wkCustHtmlArr[4], holidayHtml_dow4: wkHolHtmlArr[4],
                    dow5:  wkArr[5], dt_dow5: wkDtArr[5], isDisabled_dow5: wkIsDisArr[5], isHoliday_dow5: wkIsHolArr[5], customCls_dow5: wkCustClsArr[5], customHtml_dow5: wkCustHtmlArr[5], holidayHtml_dow5: wkHolHtmlArr[5],
                    dow6:  wkArr[6], dt_dow6: wkDtArr[6], isDisabled_dow6: wkIsDisArr[6], isHoliday_dow6: wkIsHolArr[6], customCls_dow6: wkCustClsArr[6], customHtml_dow6: wkCustHtmlArr[6], holidayHtml_dow6: wkHolHtmlArr[6]
                }); 
                id++;
                weekNum++;

            }  while (i<=numDays && i<32);
            // Process next month    


        } while (dt < endLastDt);
        me.numWeeks = (weekNum-1);  // Used to adjust matrix heights in matrixPrep() for 6-week months

        // Now define and load store from array  (denormalize in store for better rendering performance)
        var fields = [{name: 'month',type: 'string'},{name: 'mo',type: 'string'}, {name: 'year',type: 'string'},{name: 'numDays',type: 'int'},
            {name: 'rowType',type: 'string'},{name: 'weekNum',type: 'int'},{name: 'ID'},{name: 'PARENT_ID'},
            {name: 'dow0'},{name: 'dt_dow0', type: 'date'},
            {name: 'dow1'},{name: 'dt_dow1',type: 'date'},
            {name: 'dow2'},{name: 'dt_dow2',type: 'date'},
            {name: 'dow3'},{name: 'dt_dow3',type: 'date'},
            {name: 'dow4'},{name: 'dt_dow4',type: 'date'},
            {name: 'dow5'},{name: 'dt_dow5',type: 'date'},
            {name: 'dow6'},{name: 'dt_dow6',type: 'date'},

            {name: 'isDisabled_dow0', type: 'boolean'},
            {name: 'isHoliday_dow0', type: 'boolean'},
            {name: 'customCls_dow0', type: 'string'},
            {name: 'customHtml_dow0', type: 'string'},
            {name: 'holidayHtml_dow0', type: 'string'},

            {name: 'isDisabled_dow1', type: 'boolean'},
            {name: 'isHoliday_dow1', type: 'boolean'},
            {name: 'customCls_dow1', type: 'string'},
            {name: 'customHtml_dow1', type: 'string'},
            {name: 'holidayHtml_dow1', type: 'string'},

            {name: 'isDisabled_dow2', type: 'boolean'},
            {name: 'isHoliday_dow2', type: 'boolean'},
            {name: 'customCls_dow2', type: 'string'},
            {name: 'customHtml_dow2', type: 'string'},
            {name: 'holidayHtml_dow2', type: 'string'},

            {name: 'isDisabled_dow3', type: 'boolean'},
            {name: 'isHoliday_dow3', type: 'boolean'},
            {name: 'customCls_dow3', type: 'string'},
            {name: 'customHtml_dow3', type: 'string'},
            {name: 'holidayHtml_dow3', type: 'string'},

            {name: 'isDisabled_dow4', type: 'boolean'},
            {name: 'isHoliday_dow4', type: 'boolean'},
            {name: 'customCls_dow4', type: 'string'},
            {name: 'customHtml_dow4', type: 'string'},
            {name: 'holidayHtml_dow4', type: 'string'},

            {name: 'isDisabled_dow5', type: 'boolean'},
            {name: 'isHoliday_dow5', type: 'boolean'},
            {name: 'customCls_dow5', type: 'string'},
            {name: 'customHtml_dow5', type: 'string'},
            {name: 'holidayHtml_dow5', type: 'string'},   

            {name: 'isDisabled_dow6', type: 'boolean'},
            {name: 'isHoliday_dow6', type: 'boolean'},
            {name: 'customCls_dow6', type: 'string'},
            {name: 'customHtml_dow6', type: 'string'},
            {name: 'holidayHtml_dow6', type: 'string'}               
            ];

        var tempstore = gridlist.getStore(); // Created when TouchTreeGrid is instantiated

        var gridstore = Ext.create('Ext.data.TreeStore', {root: {children: []}, fields: fields});  

        gridlist.setStore(gridstore);
        me.storeId = gridstore.getStoreId();  // Save so that we can destroy it in onDestroy() method when cleaning up

        if (!Ext.isEmpty(tempstore)) {
            Ext.data.StoreManager.unregister(tempstore);
        }

        gridlist.dateArr = dateArr; // Store for resuse on expand/collapse all

        me.loadStore(me, gridcont, gridlist, expandCollapse);
    },

    loadStore: function(me, gridcont, gridlist, expandCollapse) {
        var i, j;

        var dateArr = gridlist.dateArr;  // Saved in createStore() method
        var gridstore = gridlist.getStore();

        var selDtArr = me.getSelDtArr();

        var today= Ext.Date.clearTime(new Date(Date(Ext.Date.now())), true);
        var currMonth = Ext.Date.format(today, 'm');
        var currYear = Ext.Date.format(today, 'Y');
        var filter = me.getFilter();
        var reverseSort = me.getReverseSort();
        var collapseLevel = gridcont.getDefaultCollapseLevel();

        var fldLstArr = [['month',0],['mo', 0],['year',0],['numDays',0],['rowType',0],['weekNum',0],['ID',0],['PARENT_ID',0],  
        ['dow0',0],['dt_dow0',0],['dow1',0],['dt_dow1',0],['dow2',0],['dt_dow2',0],['dow3',0],['dt_dow3',0],
        ['dow4',0],['dt_dow4',0],['dow5',0],['dt_dow5',0],['dow6',0],['dt_dow6',0],
        ['isDisabled_dow0',0],['isHoliday_dow0',0],
        ['isDisabled_dow1',0],['isHoliday_dow1',0],
        ['isDisabled_dow2',0],['isHoliday_dow2',0],
        ['isDisabled_dow3',0],['isHoliday_dow3',0],
        ['isDisabled_dow4',0],['isHoliday_dow4',0],
        ['isDisabled_dow5',0],['isHoliday_dow5',0],
        ['isDisabled_dow6',0],['isHoliday_dow6',0],
        ['customCls_dow0',0],['customHtml_dow0',0],['holidayHtml_dow0',0],
        ['customCls_dow1',0],['customHtml_dow1',0],['holidayHtml_dow1',0],
        ['customCls_dow2',0],['customHtml_dow2',0],['holidayHtml_dow2',0],
        ['customCls_dow3',0],['customHtml_dow3',0],['holidayHtml_dow3',0],
        ['customCls_dow4',0],['customHtml_dow4',0],['holidayHtml_dow4',0],
        ['customCls_dow5',0],['customHtml_dow5',0],['holidayHtml_dow5',0],
        ['customCls_dow6',0],['customHtml_dow6',0],['holidayHtml_dow6',0]];

        var treejson = this.getTree(dateArr, null, collapseLevel, fldLstArr, false, filter);

        if (reverseSort) {
            treejson.children.sort(function(b, a){
                var nameA=a.year+a.mo, nameB=b.year+b.mo;
                if (nameA < nameB){ //sort string ascending
                return -1 ;}
                if (nameA > nameB){
                return 1;}
                return 0; //default return value (no sorting)
            });
        }

        gridstore.suspendEvents();
        gridstore.removeAll();  // Mainly useful for expand/collapse all where we are rebuilding treestore
        gridstore.resumeEvents(true); // "discard queued events" improves performance when filtering and/or expanding all


        var gridloaded = gridstore.setData(treejson);  // setRoot() not working => http://www.sencha.com/forum/showthread.php?242257


        // Locate first parent node with selected dates, else current month
        // Also locate current month node
        var minDt = Ext.Array.min(selDtArr);
        var minYr = (!Ext.isEmpty(minDt) ? minDt.substring(0,4) : currYear);   
        var minMo = (!Ext.isEmpty(minDt) ? minDt.substring(5,7) : currMonth);
        var currYrMo = currYear+currMonth;
        var firstYrMo = minYr+minMo;
        gridcont.firstMoCnt = 0;
        gridcont.currentMoCnt = 0;
        for (i=0; i< treejson.children.length; i++) {
            if (treejson.children[i].year+treejson.children[i].mo===currYrMo) {gridcont.currentMoCnt = i;}    
            if (treejson.children[i].year+treejson.children[i].mo===firstYrMo) {gridcont.firstMoCnt = i;}
        }
        // Update parameters to scroll to appropriate month after scroller is refreshed (via onScrollerRefresh method)
        me.needToScroll = !Ext.isEmpty(minDt);


        // Expand current month  (unless specifically collapsing all)
        if (!expandCollapse && me.getExpandCurrentMonth()) {
            var currRec = gridstore.getAt(gridcont.currentMoCnt);
            if (!Ext.isEmpty(currRec)) {currRec.set('expanded', true);}
        }

        // autoCollapseMonthsPriorToMinSelDt
        if (me.getAutoCollapseMonthsPriorToMinSelDt() && selDtArr.length>0 && !expandCollapse) {

            // Now loop through store and collapse parent nodes prior to selection
            gridstore.each(function (item, index, length) {
                if (!item.get('leaf') && ((item.get('year') < minYr) || (item.get('year') === minYr && item.get('mo')< minMo))) {
                    item.set('expanded', false);
                }
            });   
        }

        // autoExpandMonthsWithSelDates
        var thisYr, thisMo, uniqMoYr=[];
        if (me.getAutoExpandMonthsWithSelDates() && selDtArr.length>0) {
            // Optimize to only loop for unique year/month combinations
            for (i=0; i<selDtArr.length; i++) {
                if (uniqMoYr.indexOf(selDtArr[i].substring(0,7))===-1) {
                    uniqMoYr.push(selDtArr[i].substring(0,7));
                }
            }
            uniqMoYr.sort();

            // Now loop through store and collapse parent nodes prior to selection in sorted order
            gridstore.each(function (item, index, length) {
                if (item.get('leaf') || item.get('expanded')) {return;} // no need to process this row
                for (i=0; i<uniqMoYr.length; i++) {
                    thisYr = uniqMoYr[i].substring(0,4);   
                    thisMo = uniqMoYr[i].substring(5,7);
                    if (item.get('year') === thisYr && item.get('mo')=== thisMo) {
                        item.set('expanded', true);
                    }
                }        
            });
        }

        var refreshed = gridcont.doRefreshList(true);  

        if (me.getDisableListScroll()) {gridlist.getScrollable().getScroller().setDisabled(true);}







    },

    onLeafItemTap: function(me, list, index, target, record, e) {

        var i, innerText, tgt, dt, doRefresh=false;

        innerText = e.target.innerText;
        var store = list.getStore();
        var gridcont = me;
        var dtPkr = list.parent.parent;



        var holidayDtArr = dtPkr.getHolidayDtArr();
        var disableDtArr = dtPkr.getDisableDtArr();
        var disableFutureDates = dtPkr.getDisableFutureDates();
        var disableHolidays = dtPkr.getDisableHolidays();
        var disableWeekends = dtPkr.getDisableWeekends();
        var disablePastDates = dtPkr.getDisablePastDates();
        var enableQuickDaySelection = dtPkr.getEnableQuickDaySelection();

        var selArr = dtPkr.getSelDtArr();
        var selMode = dtPkr.getSelectMode().toUpperCase();



        tgt = e.getTarget(null,null,true);

        var myField = e.target.getAttribute('dataIndex');
        if (Ext.isEmpty(myField)) {
            myField = e.target.parentElement.getAttribute('dataIndex');  // check parent element also
            if (Ext.isEmpty(myField)) {return;}
            tgt=tgt.getParent();
        } 

        if (tgt.hasCls('calendarpicker-disabled')) {return;}  // do nothing for disabled rows

        var myDate = record.get('dt_'+myField);
        if (Ext.isEmpty(myDate)) {return;}

        var myDateStr = Ext.Date.format(myDate, 'Y-m-d');

        if (selMode === 'NONE') {
            doRefresh = true;
            //  if (doRefresh) {list.refresh();}

            if (enableQuickDaySelection) {
                tgt.toggleCls('calendarpicker-selected');  // temporarily toggle selection appearance
            }

            // Slight delay so user sees selection in calendar 
            setTimeout(function(){
                if (enableQuickDaySelection) {        
                    tgt.toggleCls('calendarpicker-selected');  // reset selection appearance
                }
                dtPkr.fireEvent('dateSelected', dtPkr, myDateStr, myDate);
            },100);

        }
        else if (selMode === 'MULTI') {
            // remove all occurrences of selected/deselected date from array (in case duplicated)
            for(i = selArr.length - 1; i >= 0; i--) {
                if(selArr[i] === myDateStr) {
                    selArr.splice(i, 1);
                }
            }

            if (!tgt.hasCls('calendarpicker-selected')) {  // new selection
                dtPkr.setLastSelectedDate(myDateStr);  // updated with last selected 
                selArr.push(myDateStr);  // add selected date to array
            } 

            dtPkr.setSelDtArr(selArr); // update object
            tgt.toggleCls('calendarpicker-selected');
        }

        else if (selMode === 'SINGLE') {  // only one selection allowed and window closed
            doRefresh = true;
            // Remove all entries in SelDtArr and in Store not matching current selection
            for (i=0; i<selArr.length; i++){
                // check if we need to re-invoke renderer to deselect prior selections
                if (selArr[i] !== myDateStr) {doRefresh=true;} 
            }
            selArr=[];  // reset array

            if (!tgt.hasCls('calendarpicker-selected')) {  // new selection
                dtPkr.setLastSelectedDate(myDateStr);  // updated with last selected        
                selArr.push(myDateStr);  // add selected date to array
            } 

            dtPkr.setSelDtArr(selArr); // update object
            tgt.toggleCls('calendarpicker-selected');

            if (doRefresh) {list.refresh();}

            // Slight delay so user sees selection in calendar 
            setTimeout(function(){
                dtPkr.fireEvent('calendarClosed', dtPkr);
            },250);
        }

        else if (selMode === 'RANGE') {
            // First update selection
            // remove all occurrences of selected/deselected date from array (in case duplicated)
            for(i = selArr.length - 1; i >= 0; i--) {
                if(selArr[i] === myDateStr) {
                    selArr.splice(i, 1);
                }
            }

            if (!tgt.hasCls('calendarpicker-selected')) {  // new selection
                dtPkr.setLastSelectedDate(myDateStr);  // updated with last selected 
                selArr.push(myDateStr);  // add selected date to array
            } 
            tgt.toggleCls('calendarpicker-selected');   

            // Now get minimum and maximum ranges
            if (selArr.length > 1) {
                var maxDt = Ext.Array.max(selArr);
                var minDt = Ext.Array.min(selArr);

                if (!Ext.isEmpty(minDt) && !Ext.isEmpty(maxDt) && (minDt !== maxDt)) {
                    // Populate array with all dates in between min and max skipping disabled dates
                    var newArr = [], d=minDt, dact;
                    doRefresh=true;

                    do {
                        dact = Ext.Date.parse(d, 'Y-m-d');

                        if ((disableDtArr.indexOf(d) === -1) &&
                        (!disableFutureDates || (d <= gridcont.todayDt) ) &&
                        (!disableWeekends || (Ext.Date.format(dact, 'w')!=='0' && Ext.Date.format(dact, 'w')!=='6')) &&
                        (!disableHolidays || (holidayDtArr.indexOf(d)===-1) ) &&
                        (!disablePastDates || (d >= gridcont.todayDt))) {
                            newArr.push(d);
                        }

                        // Increment d
                        dtmp = Ext.Date.clone(dact);
                        dact = Ext.Date.add(dtmp, Ext.Date.DAY, 1);  // next day
                        d = Ext.Date.format(dact, 'Y-m-d');                                    
                        if (Ext.Date.format(dtmp, 'Y-m-d')===d) {
                            // Correct for day light savings changes were add() method only adds 23 hours
                            dact = Ext.Date.add(dact, Ext.Date.DAY, 1);  // next day
                            d = Ext.Date.format(dact, 'Y-m-d');                    
                        }
                    } while (d<=maxDt); 
                    selArr = newArr.slice(0); // clone from newArr[]
                }        
            }


            dtPkr.setSelDtArr(selArr); // update object

            if (doRefresh) {list.refresh();}

        }

        else {
            Ext.Msg.alert('Invalid selectMode !');
            console.log('Invalid selectMode (MULTI, SINGLE, RANGE) '); 
        }




    },

    customBtns: function(btnName) {
        var dtPkr = this;

        if (btnName === 'CLEAR') {
            dtPkr.setSelDtArr([]);
            dtPkr.setLastSelectedDate('');           
            dtPkr.gridlist.refresh();
        }

        if (btnName === 'CANCEL') {
            dtPkr.setSelDtArr(dtPkr.origSelDtArr);
            dtPkr.gridlist.refresh();   

            setTimeout(function(){
                dtPkr.fireEvent('calendarClosed', dtPkr);
            },250);    
        }

        if (btnName === 'DONE') {
            // Slight delay so user sees selection in calendar 
            setTimeout(function(){
                dtPkr.fireEvent('calendarClosed', dtPkr);
            },250);
        }


    },

    onScrollerRefresh: function() {
        // Workaround to get list to scroll to first month with seleted dates (or current month) after scroller has been refreshed
        if (this.needToScroll && this.gridcont.firstMoCnt>0) {   
            var list = this.gridlist;
            var idx  = this.gridcont.firstMoCnt;
            var monthNodeHeightInPixels = this.getMonthNodeHeightInPixels();    
            var offset = monthNodeHeightInPixels*idx;
            this.scroller.scrollTo(0,offset, false); 
        }




    },

    onExpCollapse: function(params) {
        // For larger data sets expand/collapse faster by refreshing the treestore with appropriate collapse level
        this.gridcont.setDefaultCollapseLevel(params.collapseLevel);

        this.gridlist.setMasked({xtype: 'loadmask', message: "Working..."});
        this.loadStore(this, this.gridcont, this.gridlist, true);
        this.gridlist.setMasked(false);
        this.scroller.scrollTo(0,1);


    },

    onDestroy: function() {
        // Up to Developer to destroy each instance of CalendarPicker component upon selection.
        // This method does additional cleanup triggered off destroy event to clean up Stores, etc...
        var me = this;

        var storeId = me.storeId; // saved in createStore() method

        var stores = Ext.data.StoreManager;

        var gridstore = stores.lookup(storeId);
        if (!Ext.isEmpty(gridstore)) {
            stores.unregister(gridstore);
        }

    },

    onInsertMonths: function() {
        // Listens to PullRefresh plugin lastestfetched event to insert months to displayed calendar
        // Refer to initialize() method:  me.on('insertMonths', me.onInsertMonths, me);
        var backMonths = this.getBackMonths();
        var monthsToInsert = this.getMonthsToInsert();
        this.setBackMonths(backMonths+monthsToInsert);

        this.gridlist.setMasked({xtype: 'loadmask', message: "Working..."});
        this.createStore(this, this.gridcont, this.gridlist, false);
        this.gridlist.setMasked(false);
        this.scroller.scrollTo(0,1); 

    },

    onAppendMonths: function() {
        var forwardMonths = this.getForwardMonths();
        var monthsToAppend = this.getMonthsToAppend();
        this.setForwardMonths(forwardMonths+monthsToAppend);

        this.gridlist.setMasked({xtype: 'loadmask', message: "Working..."});
        this.createStore(this, this.gridcont, this.gridlist, false);
        this.gridlist.setMasked(false);
        this.scroller.scrollToEnd();


    },

    onAppendMatrixMonths: function() {
        this.matrixPrep(this.config, true);
    },

    getTree: function(list, rootId, expLevel, fldListArr, hasTopRoot, filterOpts) {
        // Required Fields:  'ID', 'PARENT_ID'   
        // list       - data array to convert to treestore format
        // rootId     - value of ultimate PARENT_ID (can be null)
        // expLevel   - level to expand treestore to while generating
        // fldListArr - defines columns to include in treestore from ArrRef for specific levels (if empty array then all fields are included at all levels as provided in list[])
        //              2nd parameter defines levels including and higher where data element will be blanked out when generating the treestore
        //              (particularly used for totalled numerics that don't apply to root levels, but the generating SQL can't update as NULL due to SQL UNION constraints 
        //              Note:  Exclude ID, PARENT_ID columns as these will be auto-added
        //              For each field define level "up to which" values will be included on category rows.
        //               '0' means highest root row will include non-nullable values (or as defined in flat file) for this field.
        //               '1' means level 1 categories will include data (if defined)
        //               '2' means data will only be included for up to level 2.  Level 1 and root will not show data for this column.
        //                etc...
        //              Example:   fldListArr = [['YearMonth', 0], ['grouper', 0], ['CloseDate', 1], ['Open', 1], ... ]
        // hasTopRoot - true if a single root row exists
        // filterOpts - Object defining filter options with members as follows:
        //               - enabled : true or false (default)
        //               - displayNodesWithAllMembersFilteredAsLeafs : true (default) or false 
        //                   (if, as result of filter a node has no displayable children, then set to true so that it appears
        //                    as a leaf, or false to dispaly as expandable node ... regardless would not be expandable)
        //               - filterFn : function that returns true if row is to be included in results
        //
        //               Example:
        //               filterOpts = {
        //                  enabled: true,
        //                  displayNodesWithAllMembersFilteredAsLeafs: true,
        //                  filterFn: function (rowObj) {return (parseInt(rowObj.Female) < parseInt(rowObj.Male));}
        //               };
        //
        //               Notes about filtering:
        //               - Node is included if any of it's children are included (whether node passes filter test or not!)
        //               - 
        //
        expLevel = (Ext.isEmpty(expLevel) ? 99 : expLevel);  // Level for initial expansion ...Defaults to fully expanded if not provided

        if (fldListArr.length===0) {
            // Initialize fldListArr with default values from all data fields in first row of list[]
            for (fld in list[0]) {
                if (fld !== 'ID' && fld !== 'PARENT_ID') {  // These are auto-added in createTreeStructure()
                    fldListArr.push([fld, 0]);
                }
            }
        }
        var tree, root = {}, result = []; // fetch list from database
        root.ID = rootId;
        tree = {text : "."};
        result.push(this.createTreeStructure(tree, root, list, 1, expLevel, fldListArr, hasTopRoot, filterOpts).result);
        return result[0][0];

    },

    createTreeStructure: function(tree, root, list, level, expLevel, fldListArr, hasTopRoot, filterOpts) {
        var i=0, result = [], child, childList = [], children = [], temptree = {}, thisExp,
            has_nonfiltered_child = false;

        // Initialize Filter option variables
        filterOpts = (Ext.isEmpty(filterOpts) ? {} : filterOpts);
        var filtEnabled = (Ext.isEmpty(filterOpts.enabled) ? false : filterOpts.enabled);
        var filtNodesAsLeafs = (Ext.isEmpty(filterOpts.displayNodesWithAllMembersFilteredAsLeafs) ? true : filterOpts.displayNodesWithAllMembersFilteredAsLeafs);
        var filtFn = (Ext.isEmpty(filterOpts.filterFn) ? undefined : filterOpts.filterFn);

        if (level === 1 && hasTopRoot) {children = [list[0]];}  // Initial root
        else {children = this.getChildren(root, list, false);} //Fetch children

        var ln = children.length;

        for(i=0; i<ln;i++)
        {
            child = children[i];
            // Blank out categorized data above specified level as pre-specified in fldListArr
            // Example:  we may have 3 levels of cateogries.  Details sum to to the 3rd and perhaps 2nd level, 
            //           but the 1st level should leave this column empty as not desired or applicable.
            for (var j=0; j< fldListArr.length; j++) {
                if (fldListArr[j][1] > 0 && fldListArr[j][1]>=level) {child[fldListArr[j][0]] = '';}
            }

            if(this.getChildren(child, list, true).length===0) 
            {
                temptree = {LEVEL : level, ID : child.ID, PARENT_ID : child.PARENT_ID, leaf : true};
                this.assignMembers(fldListArr, temptree, child);

                // Push child to tree if filter not enabled or if passes filter condition
                if (!filtEnabled || filtFn(temptree)) { 
                    childList.push(temptree);
                    tree["children"] = childList; // Add leaf to child array of the passed parent (also links arrays)
                    has_nonfiltered_child = true;
                }
            }
            else
            {
                thisExp = (level < expLevel ? true : false);
                temptree = {LEVEL : level, ID : child.ID, PARENT_ID : child.PARENT_ID, expanded : thisExp, leaf : false}; 
                this.assignMembers(fldListArr, temptree, child);

                // Push to children array now, but we will Pop it back later if this record and all children fail the filter condition
                childList.push(temptree);
                tree["children"] = childList;  // Add node to child array of passed parent (also links arrays)

                // Recursively create tree structure for the child since children exist.
                if (!this.createTreeStructure(temptree, child, list, level+1, expLevel, fldListArr, hasTopRoot, filterOpts).has_nonfiltered_child) {
                    // If child items are all fitlered, but node passes filter test then  load this node as leaf instead of node (unless specified otherwise)
                    if (!filtEnabled || filtFn(temptree)) {
                        tree.children[tree.children.length-1].leaf = filtNodesAsLeafs;
                        tree.children[tree.children.length-1].expanded = false;
                        tree.children[tree.children.length-1].expandable = false;  // disallow expand all children are filtered 
                        has_nonfiltered_child = true;

                    } else {
                        tree.children.pop();    // If HAS_NONFILTERED_CHILD = false, then pop() per above
                    }
                } else {
                    has_nonfiltered_child = true;
                }

            }
        }

        result.push(tree);   // DON'T NEED TO DO THIS UNTIL DONE WITH FINAL ITERATION
        return {result: result, has_nonfiltered_child: has_nonfiltered_child};

    },

    assignMembers: function(fldListArr, treeObj, child) {
        for (var i=0; i< fldListArr.length; i++) {
            if (fldListArr[i][0]  !== 'ID' && fldListArr[i][0] !== 'PARENT_ID') {
                treeObj[fldListArr[i][0]] = child[fldListArr[i][0]];
            }
        }
    },

    getChildren: function(root, list, firstOnly) {
        var i=0, ln = list.length, result = [];
        for(i=0; i<ln;i++)
        {
            if(root.ID===list[i].PARENT_ID)
            {
                result.push(list[i]);
                if (firstOnly) {return result;} // Only checking if single child exists so abort upon first detection
            }
        }
        return result;
    }

});